//?	Mix (WPF3)
//!	Mixins globais para uso no seu projeto:

//* Instâncias: extensões da folha de estilos:
@use "sass:color"			as color;
@use "sass:math"			as math;

/**
	*#	Add Vendors
	*	Adiciona prefixos nas propriedades CSS compatíveis com múltiplos browsers:
	*
	*	$property 			-> Propriedade CSS a receber os prefixos.
	*	$value 				-> O valor da propriedade.
*/
@mixin addVendors(
	$property, 
	$value
){
	-webkit-#{$property}: 	#{$value};
   	-moz-#{$property}: 		#{$value};
   	-ms-#{$property}: 		#{$value};
   	-o-#{$property}: 		#{$value};
   	#{$property}: 			#{$value};
}

/**
	**	Center Position: [https://webeponto.notion.site/centerPosition-59c4c231d4b24155a2b314b9428ed13a]
	*	Centraliza um elemento absolute na horizontal, vertical ou em ambos os sentidos.
	*
	*	$direction 			-> Sentido da centralização. Utilize 'H' para horizontal, 'V' para vertical ou 'C' para ambos.
	*	$type	 			-> Tipo de centralização. Utilize 'absolute', 'relative' ou 'fixed'.
*/
@mixin centerPosition(
	$direction: 'H',
	$type: absolute
){
	position: $type;

	// Define qual é o sentido da centralização:
	@if($direction == 'H')
	{
		left:	 			50%;
		transform: 			translateX(-50%);
	}

	// Define qual é o sentido da centralização:
	@else if($direction == 'V')
	{
		top:	 			50%;
		transform: 			translateY(-50%);
	}

	// Define qual é o sentido da centralização:
	@else if($direction == 'C')
	{
		top:	 			50%;
		left:	 			50%;
		transform: 			translateY(-50%)
				 			translateX(-50%);
	}

	@else
	{
		@warn "O prefixo utilizado não é válido. Utilize 'H' para horizontal, 'V' para vertical ou 'C' para ambos.";
	}
}

/**
	*#	Render Arrow
	*	Renderiza a forma de uma seta na posição desejada.
	*
	*	$direction 			-> Direção à qual a seta está apontando. Utilize 'top', 'right', 'bottom ou 'left'.
	*	$size 				-> Tamanho da seta, em pixels.
	*	$color 				-> Cor da seta.
*/
@mixin renderArrow(
	$direction: bottom,
	$size: 5px,
	$color: #FFF
){
	width: 					0;
   	height: 				0;

   	@if ($direction == left)
	{
		border-top: 		$size solid transparent;
		border-bottom: 		$size solid transparent; 
		border-right: 		$size solid $color;
   	}

	@else if ($direction == right)
	{
		border-top: 		$size solid transparent;
		border-bottom: 		$size solid transparent; 
		border-left: 		$size solid $color;
	}

	@else if ($direction == bottom)
	{
		border-left: 		$size solid transparent;
		border-right: 		$size solid transparent;
		border-top: 		$size solid $color;
	}

	@else if ($direction == top)
	{
		border-left: 		$size solid transparent;
		border-right: 		$size solid transparent;
		border-bottom: 		$size solid $color;
	}

	@else
	{
		@warn "O prefixo utilizado não é válido. Utilize 'top', 'right', 'bottom ou 'left'.";
	}
}

/**
	*#	Responsive
	*	Prepara o CSS para receber estilos responsivos.
	*
	*	$type	 			-> Se o responsivo está calculando o tamanho máximo ou mínimo da tela. Utilize 'max' ou 'min'.
	*	$pixels				-> Tamanho da tela.
*/
@mixin responsive(
	$pixels: 1023px,
	$type: max
){
	@media screen and (#{$type}-width: $pixels){
        @content;
    }
}

/**
	**	Set Position: [https://webeponto.notion.site/setPosition-9477420819f44b6facc74e5e796d93f0]
	*	Configura o posicionamento absolute de um elemento.
	*
	*	$top 				-> Posicionamento superior. Utilize 'auto' para ignorar.
	*	$top 				-> Posicionamento da direita. Utilize 'auto' para ignorar.
	*	$top 				-> Posicionamento inferior. Utilize 'auto' para ignorar.
	*	$top 				-> Posicionamento da esquerda. Utilize 'auto' para ignorar.
	*	$type 				-> Tipo de posicionamento. Utilize 'absolute', 'relative' ou 'fixed'.
*/
@mixin setPosition(
	$top: auto,
	$right: auto,
	$bottom: auto,
	$left: auto,
	$type: absolute
){
	position: 				$type;
	top: 					#{$top};
	right: 					#{$right};
	bottom: 				#{$bottom};
	left: 					#{$left};
}

/**
	*#	Short Text
	*	Concatena reticências à qualquer texto que ultrapasse a largura máxima de seu elemento mãe.
*/
@mixin shortText()
{
   	text-overflow: 			ellipsis;
   	white-space: 			nowrap;
	overflow: 				hidden;
}

/**
	*#	Manage Z-Index
	*	Organiza elementos filhos com posicionamentos absolutos no eixo Z baseados em uma ordem crescente ou decrescente.
*/
@mixin manageZIndex(
	$order: "ASC",
	$count: 5
){
	$target: 0;

	@if($order == "DESC" )
	{
		$index: $count;

		@while($index > 0)
		{
			&:nth-child(#{$target}){
				z-index: #{$index}; 
			}

			$target: $target + 1;
			$index: $index - 1;
		}
	}

	@else if ($order == "ASC")
	{
		$index: 0;

		@while($index <= $count)
		{
			&:nth-child(#{$target}){
				z-index: #{$index};
			}

			$target: $target + 1;
			$index: $index + 1;
		}
	}

	@else
	{
		@warn "Os parâmetros declarados estão incorretos.";
	}
}

/**
	*#	Container
	*	Prepara o CSS para receber estilos responsivos locais.
	*
	*	$name	 			-> O nome do container (obrigatório). Os nomes nunca devem se repetir.
	*	$type	 			-> Se o responsivo está calculando o tamanho máximo ou mínimo da tela. Utilize 'max' ou 'min'.
	*	$axis	 			-> Se o responsivo está calculando o eixo X ou Y do container. Utilize 'width' ou 'height'.
	*	$pixels				-> Tamanho do container.
*/
@mixin container(
	$name,
	$type: min,
	$axis: width,
	$pixels: 500px
){
	@if($name)
	{
		@container #{$name} (#{$type}-#{$axis}: #{$pixels}){
			@content;
		}
	}

	@else 
	{
		@warn "O método 'container' necessita ter um nome e método especificado. Por favor especifique um nome e um método para o seu @container."
	}
}

/**
	*#	Generate Grid
	*	Cria um sistema de grid responsivo com colunas automáticas.
	*
	*	$columns			-> Número de colunas desejadas.
	*	$gap				-> Espaçamento entre os elementos.
	*	$min-width			-> Largura mínima de cada coluna antes de quebrar.
	*	$align				-> Alinhamento dos itens. Utilize 'start', 'center', 'end' ou 'stretch'.
*/
@mixin generateGrid(
	$columns: auto-fit,
	$gap: 1rem,
	$min-width: 250px,
	$align: stretch
){
	display: 				grid;
	grid-template-columns: 	repeat(#{$columns}, minmax(#{$min-width}, 1fr));
	gap: 					#{$gap};
	align-items: 			#{$align};
}

/**
	*#	Flex Center
	*	Centraliza elementos usando flexbox com opções avançadas.
	*
	*	$direction			-> Direção do flex. Utilize 'row', 'column', 'row-reverse' ou 'column-reverse'.
	*	$justify			-> Justificação horizontal. Utilize 'center', 'start', 'end', 'space-between', 'space-around'.
	*	$align				-> Alinhamento vertical. Utilize 'center', 'start', 'end', 'stretch', 'baseline'.
	*	$gap				-> Espaçamento entre elementos.
*/
@mixin flexCenter(
	$direction: row,
	$justify: center,
	$align: center,
	$gap: 0
){
	display: 				flex;
	flex-direction: 		#{$direction};
	justify-content: 		#{$justify};
	align-items: 			#{$align};
	
	@if($gap != 0)
	{
		gap: 				#{$gap};
	}
}

/**
	*#	Generate Shadow
	*	Cria sombras personalizadas com múltiplas camadas.
	*
	*	$type				-> Tipo de sombra. Utilize 'soft', 'medium', 'hard', 'glow' ou 'custom'.
	*	$color				-> Cor da sombra.
	*	$custom				-> Valores customizados quando $type é 'custom'.
*/
@mixin generateShadow(
	$type: soft,
	$color: rgba(0, 0, 0, 0.1),
	$custom: null
){
	@if($type == soft)
	{
		box-shadow: 		0 2px 8px #{$color},
							0 1px 3px rgba(0, 0, 0, 0.06);
	}

	@else if($type == medium)
	{
		box-shadow: 		0 4px 16px #{$color},
							0 2px 6px rgba(0, 0, 0, 0.1);
	}

	@else if($type == hard)
	{
		box-shadow: 		0 8px 32px #{$color},
							0 4px 12px rgba(0, 0, 0, 0.15);
	}

	@else if($type == glow)
	{
		box-shadow: 		0 0 20px #{$color},
							0 0 40px rgba(color.red($color), color.green($color), color.blue($color), 0.3);
	}

	@else if($type == custom and $custom)
	{
		box-shadow: 		#{$custom};
	}

	@else
	{
		@warn "Tipo de sombra inválido. Utilize 'soft', 'medium', 'hard', 'glow' ou 'custom' com valores customizados.";
	}
}

/**
	*#	Aspect Ratio
	*	Define uma proporção de aspecto para elementos.
	*
	*	$ratio				-> Proporção desejada. Ex: '16/9', '4/3', '1/1', etc.
	*	$method				-> Método de implementação. Utilize 'modern' ou 'legacy'.
*/
@mixin aspectRatio(
	$ratio: 1/1,
	$method: modern
){
	@if($method == modern)
	{
		aspect-ratio: 		#{$ratio};
	}

	@else if($method == legacy)
	{
		position: 			relative;
		overflow: 			hidden;

		&::before
		{
			content: 		'';
			display: 		block;
			padding-top: 	math.div(1, #{$ratio}) * 100%;
		}

		> *
		{
			position: 		absolute;
			top: 			0;
			left: 			0;
			width: 			100%;
			height: 		100%;
		}
	}

	@else
	{
		@warn "Método inválido. Utilize 'modern' ou 'legacy'.";
	}
}

/**
	*#	Gradient Background
	*	Cria backgrounds gradientes personalizados.
	*
	*	$type				-> Tipo de gradiente. Utilize 'linear', 'radial' ou 'conic'.
	*	$direction			-> Direção (para linear) ou posição (para radial). Ex: 'to right', 'circle at center'.
	*	$colors				-> Lista de cores do gradiente.
*/
@mixin gradientBackground(
	$type: linear,
	$direction: to right,
	$colors: (#3b82f6, #8b5cf6)
){
	@if($type == linear)
	{
		background: 		linear-gradient(#{$direction}, #{$colors});
	}

	@else if($type == radial)
	{
		background: 		radial-gradient(#{$direction}, #{$colors});
	}

	@else if($type == conic)
	{
		background: 		conic-gradient(#{$direction}, #{$colors});
	}

	@else
	{
		@warn "Tipo de gradiente inválido. Utilize 'linear', 'radial' ou 'conic'.";
	}
}

/**
	*#	Animate Property
	*	Cria animações CSS personalizadas facilmente.
	*
	*	$name				-> Nome único da animação.
	*	$duration			-> Duração da animação.
	*	$timing				-> Função de timing. Ex: 'ease', 'linear', 'ease-in-out'.
	*	$iteration			-> Número de repetições. Use 'infinite' para loop infinito.
	*	$direction			-> Direção da animação. Ex: 'normal', 'reverse', 'alternate'.
*/
@mixin animateProperty(
	$name,
	$duration: 1s,
	$timing: ease-in-out,
	$iteration: 1,
	$direction: normal
){
	animation: 				#{$name} #{$duration} #{$timing} #{$iteration} #{$direction};

	@keyframes #{$name}
	{
		@content;
	}
}

/**
	*#	Button Style
	*	Cria estilos de botão reutilizáveis com estados.
	*
	*	$bg					-> Cor de fundo.
	*	$text				-> Cor do texto.
	*	$border				-> Cor da borda.
	*	$hover-bg			-> Cor de fundo no hover.
	*	$hover-text			-> Cor do texto no hover.
	*	$radius				-> Border radius.
	*	$padding			-> Padding interno.
*/
@mixin buttonStyle(
	$bg: #3b82f6,
	$text: white,
	$border: transparent,
	$hover-bg: #2563eb,
	$hover-text: white,
	$radius: 6px,
	$padding: 0.75em 1.5em
){
	display: 				inline-flex;
	align-items: 			center;
	justify-content: 		center;
	padding: 				#{$padding};
	background: 			#{$bg};
	color: 					#{$text};
	border: 				1px solid #{$border};
	border-radius: 			#{$radius};
	text-decoration: 		none;
	cursor: 				pointer;
	transition: 			all 0.2s ease-in-out;
	user-select: 			none;

	&:hover:not(:disabled)
	{
		background: 		#{$hover-bg};
		color: 				#{$hover-text};
		transform: 			translateY(-1px);
	}

	&:active:not(:disabled)
	{
		transform: 			translateY(0);
	}

	&:disabled
	{
		opacity: 			0.6;
		cursor: 			not-allowed;
		transform: 			none !important;
	}
}

/**
	*#	Card Style
	*	Cria estilos de card com sombra e hover effects.
	*
	*	$background			-> Cor de fundo do card.
	*	$border				-> Cor da borda.
	*	$radius				-> Border radius.
	*	$shadow				-> Tipo de sombra ('soft', 'medium', 'hard').
	*	$hover-lift			-> Se deve ter efeito de elevação no hover.
*/
@mixin cardStyle(
	$background: white,
	$border: #e5e7eb,
	$radius: 8px,
	$shadow: soft,
	$hover-lift: true
){
	background: 			#{$background};
	border: 				1px solid #{$border};
	border-radius: 			#{$radius};
	transition: 			all 0.3s ease-in-out;

	@include generateShadow($shadow);

	@if($hover-lift)
	{
		&:hover
		{
			transform: 		translateY(-2px);
			@include generateShadow(medium);
		}
	}
}

/**
	*#	Scrollbar Style
	*	Personaliza a aparência das scrollbars.
	*
	*	$width				-> Largura da scrollbar.
	*	$track-color		-> Cor da trilha da scrollbar.
	*	$thumb-color		-> Cor do indicador da scrollbar.
	*	$thumb-hover		-> Cor do indicador no hover.
	*	$radius				-> Border radius do indicador.
*/
@mixin scrollbarStyle(
	$width: 8px,
	$track-color: #f1f5f9,
	$thumb-color: #cbd5e1,
	$thumb-hover: #94a3b8,
	$radius: 4px
){
	&::-webkit-scrollbar
	{
		width: 				#{$width};
		height: 			#{$width};
	}

	&::-webkit-scrollbar-track
	{
		background: 		#{$track-color};
		border-radius: 		#{$radius};
	}

	&::-webkit-scrollbar-thumb
	{
		background: 		#{$thumb-color};
		border-radius: 		#{$radius};
		transition: 		background 0.2s ease;

		&:hover
		{
			background: 	#{$thumb-hover};
		}
	}
}

/**
	*#	Text Gradient
	*	Aplica gradiente ao texto usando background-clip.
	*
	*	$gradient			-> Gradiente a ser aplicado.
	*	$fallback			-> Cor de fallback para browsers não compatíveis.
*/
@mixin textGradient(
	$gradient: linear-gradient(45deg, #3b82f6, #8b5cf6),
	$fallback: #3b82f6
){
	background: 			#{$fallback};
	background: 			#{$gradient};
	-webkit-background-clip: text;
	background-clip: 		text;
	-webkit-text-fill-color: transparent;
	text-fill-color: 		transparent;
}
